<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Mission Log</title>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen&family=Noto+Sans+KR:wght@700&display=swap" rel="stylesheet">
    <style>
        /* 기존 디자인 100% 동일 */
        :root { --bg-color: #0f1115; --border-color: #3b4261; --accent-color: #82aaff; --text-color: #dbe6f5; --dim-color: #1e222a; }
        body { margin: 0; padding: 0; background-color: var(--bg-color); font-family: 'Silkscreen', cursive; width: 100vw; height: 100vh; overflow: hidden; color: var(--text-color); }
        .todo-container { width: 100%; height: 100%; border: 2px solid var(--border-color); box-sizing: border-box; display: flex; flex-direction: column; }
        .header-bar { height: 32px; flex-shrink: 0; border-bottom: 1px solid var(--border-color); background: rgba(59, 66, 97, 0.2); display: flex; align-items: center; justify-content: space-between; padding: 0 12px; font-size: 11px; color: var(--accent-color); }
        .header-left { display: flex; align-items: center; gap: 8px; }
        .input-area { height: 40px; flex-shrink: 0; border-bottom: 2px solid var(--border-color); display: flex; background: rgba(130, 170, 255, 0.05); }
        input { flex: 1; background: transparent; border: none; color: #ffffff; font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700; padding: 0 12px; outline: none; }
        input::placeholder { font-family: 'Silkscreen'; color: var(--accent-color); opacity: 0.5; font-size: 11px; font-weight: 400; }
        .btn-add { width: 40px; background: transparent; border: none; border-left: 1px solid var(--border-color); color: var(--accent-color); cursor: pointer; font-size: 18px; font-family: 'Silkscreen'; }
        .btn-add:hover { background: rgba(130, 170, 255, 0.2); color: #fff; }
        .mission-list { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .mission-list::-webkit-scrollbar { width: 4px; }
        .mission-list::-webkit-scrollbar-track { background: var(--bg-color); }
        .mission-list::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }
        .mission-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border: 1px solid var(--border-color); background: rgba(30, 34, 42, 0.4); transition: all 0.2s; }
        .mission-item:hover { border-color: var(--accent-color); background: rgba(30, 34, 42, 0.8); transform: translateX(2px); }
        .mission-left { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; cursor: pointer; }
        .pixel-checkbox { width: 12px; height: 12px; border: 2px solid var(--accent-color); position: relative; flex-shrink: 0; }
        .mission-item.done .pixel-checkbox { background-color: var(--accent-color) !important; box-shadow: 0 0 6px var(--accent-color); }
        .mission-item.done .pixel-checkbox::after { content: ''; position: absolute; left: 3px; top: 0px; width: 3px; height: 6px; border: solid var(--bg-color); border-width: 0 2px 2px 0; transform: rotate(45deg); }
        .text-content { font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700; color: #ffffff; line-height: 1.2; letter-spacing: -0.3px; padding-top: 2px; word-break: break-word; }
        .mission-item.done { opacity: 0.6; border-color: var(--dim-color); }
        .mission-item.done .text-content { text-decoration: line-through; color: #888; }
        .btn-action { color: #4c566a; cursor: pointer; padding: 4px 6px; opacity: 0.8; font-family: 'Silkscreen'; font-size: 10px; background: transparent; border: 1px solid var(--border-color); min-width: 24px; display: flex; align-items: center; justify-content: center; }
        .btn-action:hover { opacity: 1; }
        .btn-postpone { color: #82aaff; }
        .btn-postpone:hover { border-color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .btn-edit { color: #82aaff; }
        .btn-edit:hover { border-color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .btn-delete { color: #4c566a; }
        .btn-delete:hover { color: #ff5370; border-color: #ff5370; }
        .mission-item-actions { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }
        .mission-item.done .btn-postpone { display: none; }

        /* ✅ temp(동기화 전) 표시용 */
.mission-item.is-temp { opacity: 0.7; border-style: dashed; }
.mission-item.is-temp .mission-left { cursor: default; }
        .carryover-header { font-size: 10px; color: var(--accent-color); opacity: 0.85; padding: 6px 10px 4px; border-bottom: 1px dashed var(--border-color); margin-bottom: 4px; }
        .carryover-header::before { content: "⏪ "; }

        /* ✅ 되돌리기 토스트 */
        .undo-toast { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: var(--dim-color); border: 2px solid var(--accent-color); padding: 8px 14px; font-size: 11px; color: var(--text-color); display: flex; align-items: center; gap: 10px; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,.4); }
        .undo-toast .btn-undo { color: var(--accent-color); cursor: pointer; font-weight: 700; text-decoration: underline; background: none; border: none; font-family: inherit; }
        .undo-toast .btn-undo:hover { color: #fff; }
        
    </style>
</head>
<body>
    <div class="todo-container">
        <div class="header-bar">
            <span class="header-left">
                <span>MISSION LOG<span id="offlineBadge" style="display:none; margin-left:6px; font-size:9px; color:#ffa94d;">[테스트]</span></span>
                <span id="task-count">LOADING...</span>
            </span>
            <span id="syncStatus" style="font-size:8px; opacity:0.8;" title="동기화 상태">—</span>
        </div>
        <div class="input-area">
            <input type="text" id="input" placeholder="> TODAY'S QUEST..." autocomplete="off" title="Enter로 추가">
            <button class="btn-add" onclick="addTask()" title="할 일 추가 (Enter)">+</button>
        </div>
        <div class="mission-list" id="list"></div>
        <div id="undoToast" class="undo-toast" style="display:none;"></div>
    </div>

<script>
    const input = document.getElementById("input");
    const list = document.getElementById("list");
    const countDisplay = document.getElementById("task-count");
    
    // ✅ 오프라인 모드: ?offline=1 → Notion API 호출 안 함, localStorage만 사용 (테스트용)
    const OFFLINE_MODE = window.location.search.includes('offline=1');
    const OFFLINE_KEY = "missionlog_offline_tasks_v1";
    function loadOfflineStore(){ try{ return JSON.parse(localStorage.getItem(OFFLINE_KEY)) || {}; }catch(_){ return {}; } }
    function saveOfflineStore(obj){ localStorage.setItem(OFFLINE_KEY, JSON.stringify(obj)); }
    function getOfflineTasks(iso){ const s = loadOfflineStore(); return Array.isArray(s[iso]) ? s[iso] : []; }
    function setOfflineTasks(iso, arr){ const s = loadOfflineStore(); s[iso] = arr; saveOfflineStore(s); }
    
    // globalTasks: 오늘 할 일 목록
    let globalTasks = [];
    // carryOverTasks: 어제 미완료 할 일 (다음 날로 미룰 수 있음)
    let carryOverTasks = [];
    // deletedIds: 사용자가 '삭제' 버튼을 누른 ID들을 영원히 기억하는 블랙리스트
    let inFlight = 0; // ✅ 서버 반영 중이면 sync가 덮어쓰지 않게
    
    let deletedIds = new Set();
    let editingId = null;
    let editingCarryOver = false;

    const bc = new BroadcastChannel("missionlog_bus_v1");
        let _bcTimer = null;
        bc.onmessage = (ev) => {
          if (ev?.data?.type !== "TASKS_UPDATED") return;
          clearTimeout(_bcTimer);
          _bcTimer = setTimeout(syncFromNotion, 150);
        };

    
    const DELETED_KEY = "missionlog_deletedIds_v1";
try {
  const saved = JSON.parse(localStorage.getItem(DELETED_KEY) || "[]");
  deletedIds = new Set(saved);
} catch (_) {}
    
        // ✅ (추가) 페이지 이동/새로고침에도 유지되는 로컬 캐시
    const LOCAL_KEY = "missionlog_localTasks_v1";
    const PENDING_KEY = "missionlog_pendingTasks_v1";
    const LASTDAY_KEY = "missionlog_lastDayISO_v1";

    function removeFromPending(today, { id, text }){
  try{
    const pending = JSON.parse(localStorage.getItem(PENDING_KEY) || "{}");
    const arr = Array.isArray(pending[today]) ? pending[today] : [];
    pending[today] = arr.filter(p => !(p && (p.id === id || (text && p.text === text))));
    if (pending[today].length === 0) delete pending[today];
    localStorage.setItem(PENDING_KEY, JSON.stringify(pending));
  }catch(_){}
}

function patchPendingDone(today, { id, text }, nextDone){
  try{
    const pending = JSON.parse(localStorage.getItem(PENDING_KEY) || "{}");
    const arr = Array.isArray(pending[today]) ? pending[today] : [];
    pending[today] = arr.map(p => {
      if (!p) return p;
      if (p.id === id || (text && p.text === text)) return { ...p, done: nextDone };
      return p;
    });
    localStorage.setItem(PENDING_KEY, JSON.stringify(pending));
  }catch(_){}
}

function loadLocalTasks(){
  try{
    const arr = JSON.parse(localStorage.getItem(LOCAL_KEY) || "[]");
    if (Array.isArray(arr)) globalTasks = arr;
  }catch(_){}
}

function saveLocalTasks(){
  try{
    if (OFFLINE_MODE) {
      const today = getTodayISO();
      const yesterday = getYesterdayISO();
      const safeToday = globalTasks.filter(t => !deletedIds.has(t.id)).map(t => ({ id: t.id, text: t.text, done: t.done, date: today }));
      const safeYesterday = carryOverTasks.filter(t => !deletedIds.has(t.id)).map(t => ({ id: t.id, text: t.text, done: t.done, date: yesterday }));
      setOfflineTasks(today, safeToday);
      setOfflineTasks(yesterday, safeYesterday);
      return;
    }
    const safe = globalTasks.filter(t => !deletedIds.has(t.id));
    localStorage.setItem(LOCAL_KEY, JSON.stringify(safe));
  }catch(_){}
}
    
    let deleteArmedId = null;

    // ★ [매우 중요] 날짜 통일 함수
function getTodayISO() {
  return new Date().toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
}
function getYesterdayISO() {
  const d = new Date();
  d.setDate(d.getDate() - 1);
  return d.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
}
function getNextDayISO(iso) {
  const [y, m, d] = iso.split('-').map(Number);
  const next = new Date(y, m - 1, d + 1);
  return next.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
}
function getPrevDayISO(iso) {
  const [y, m, d] = iso.split('-').map(Number);
  const prev = new Date(y, m - 1, d - 1);
  return prev.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
}
    function reconcileDayBoundary(){
  const today = getTodayISO();
  const last = localStorage.getItem(LASTDAY_KEY);

  // ✅ 날짜가 바뀌었으면(자정 넘김) "오늘 할 일" 정책상 전날 데이터 정리
  if (last && last !== today) {
    globalTasks = [];
    try { localStorage.setItem(LOCAL_KEY, "[]"); } catch(_){}
    try { localStorage.setItem(PENDING_KEY, "{}"); } catch(_){}
  }

  localStorage.setItem(LASTDAY_KEY, today);
}

    const syncStatusEl = document.getElementById("syncStatus");
    function setSyncStatus(txt) { if (syncStatusEl) syncStatusEl.textContent = txt; }

    async function syncFromNotion() {
        if (inFlight > 0) return;
        try {
            const today = getTodayISO();
            const yesterday = getYesterdayISO();
            if (!OFFLINE_MODE) setSyncStatus("동기화중");

            // ✅ 오프라인 모드
            if (OFFLINE_MODE) {
                setSyncStatus("테스트");
                const todayTasks = getOfflineTasks(today).map(t => ({ ...t, isSynced: true, date: today }));
                carryOverTasks = getOfflineTasks(yesterday).filter(t => !t.done);
                globalTasks = todayTasks;
                saveLocalTasks();
                renderList();
                return;
            }

            const res = await fetch('/api/notion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'fetch', from: yesterday, to: today })
            });
            const data = await res.json();
            if (!res.ok || !data?.success) { setSyncStatus("실패"); return; }


            if (data.success) {
                // 1. 서버 데이터: 어제+오늘 모두 가져오기 (블랙리스트 무시)
                const allServer = (data.tasks || [])
                    .filter(t => !deletedIds.has(t.id))
                    .map(t => ({ ...t, isSynced: true, date: String(t.date || "").slice(0,10) }));
                const serverTasks = allServer.filter(t => t.date === today);
                carryOverTasks = allServer.filter(t => t.date === yesterday && !t.done);
                    // ✅ 서버에 나타난 것들은 pending 저장소에서 제거(중복 방지)
    try{
      const pending = JSON.parse(localStorage.getItem(PENDING_KEY) || "{}");
      const arr = Array.isArray(pending[today]) ? pending[today] : [];
      if (arr.length) {
        pending[today] = arr.filter(p =>
          !serverTasks.some(s =>
            (s.id && p?.id && s.id === p.id) ||
            ((s.text || "").trim() && (p?.text || "").trim() && s.text.trim() === p.text.trim() && String(s.date || "").slice(0,10) === today)
          )
        );
        localStorage.setItem(PENDING_KEY, JSON.stringify(pending));
      }
    }catch(_){}
                        // ✅ 서버에 같은 id가 잡히면 pending 해제
        for (const local of globalTasks) {
          if (local?.pending && serverTasks.some(s => s.id === local.id)) {
            local.pending = false;
          }
        }

                        // ✅ [추가] 서버에 나타난 애들은 pending 해제
        globalTasks.forEach(t => {
          if (t?.pending && serverTasks.some(s => s.id === t.id)) {
            t.pending = false;
          }
        });


                // 2. 좀비 데이터 구출 (아직 서버에 안 뜬 내 로컬 데이터)
        const zombies = globalTasks.filter(local => {
          if (deletedIds.has(local.id)) return false;
          if (local.date !== today) return false;
        
          const exists = serverTasks.some(s => s.id === local.id || s.text === local.text);
          if (exists) return false;
        
          // ✅ 1) 아직 서버에 안 뜬 temp(미동기) = 기존대로 구출
          if (!local.isSynced) return true;
        
        // ✅ 2) create는 성공했지만 fetch에 아직 안 잡혀도,
        // "오늘"이면 pending은 끝까지 유지(하루동안 유지 정책)
        if (local.pending) return true;
        
          return false;
        });

                
                // 3. 합체 및 렌더링
                globalTasks = [...serverTasks, ...zombies];
                        const seen = new Set();
        globalTasks = globalTasks.filter(t => {
          const key = (t.text || "").trim();
          if (!key) return true;
          if (seen.has(key) && t.isSynced === false) return false; // 로컬 중복 제거
          seen.add(key);
          return true;
        });
                saveLocalTasks();
                setSyncStatus("완료");
                renderList();
            }
        } catch (err) { console.error(err); setSyncStatus("실패"); }
    }

        function renderList() {
          list.innerHTML = "";
          const esc = (s) => String(s || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;");
          const escId = (id) => String(id || "").replace(/'/g, "\\'");

          function renderTaskItem(task, isCarryOver) {
            const isEditing = editingId === task.id && editingCarryOver === isCarryOver;
            if (isEditing) {
              const div = document.createElement("div");
              div.className = "mission-item";
              div.innerHTML = `
                <div class="mission-left" style="flex:1; min-width:0;">
                  <input type="text" id="editInput" value="${esc(task.text)}" maxlength="60" style="width:100%; background:#0b0c10; border:1px solid var(--border-color); color:var(--text-color); padding:6px 8px; font-size:12px; outline:none;">
                </div>
                <div class="mission-item-actions">
                  <button type="button" class="btn-action btn-edit" title="저장" onclick="event.stopPropagation(); saveEdit(); return false;">✔</button>
                  <button type="button" class="btn-action btn-delete" title="취소" onclick="event.stopPropagation(); cancelEdit(); return false;">↩</button>
                </div>
              `;
              list.appendChild(div);
              setTimeout(() => { const inp = document.getElementById("editInput"); if (inp) { inp.focus(); inp.select(); inp.onkeydown = (e) => { if (e.key==="Enter") saveEdit(); if (e.key==="Escape") cancelEdit(); }; } }, 0);
              return;
            }
            const div = document.createElement("div");
            div.className = `mission-item ${task.done ? "done" : ""} ${String(task.id||"").startsWith("temp-") ? "is-temp" : ""}`;
            const showPostpone = !task.done && !String(task.id||"").startsWith("temp-");
            div.innerHTML = `
              <div class="mission-left" onclick="toggleTask('${escId(task.id)}', ${task.done}, ${isCarryOver})">
                <div class="pixel-checkbox"></div>
                <span class="text-content">${esc(task.text)}</span>
              </div>
              <div class="mission-item-actions">
                ${showPostpone ? `<button type="button" class="btn-action btn-postpone" title="다음 날로 미루기" onclick="event.stopPropagation(); postponeTask('${escId(task.id)}', '${task.date || getTodayISO()}'); return false;">→</button>` : ""}
                <button type="button" class="btn-action btn-edit" title="수정" onclick="event.stopPropagation(); startEdit('${escId(task.id)}', ${isCarryOver}); return false;">✎</button>
                <button type="button" class="btn-action btn-delete" title="삭제" onclick="event.stopPropagation(); deleteTask('${escId(task.id)}', ${isCarryOver}); return false;">X</button>
              </div>
            `;
            list.appendChild(div);
          }

          if (carryOverTasks.length > 0) {
            const header = document.createElement("div");
            header.className = "carryover-header";
            header.textContent = "어제 미완료";
            list.appendChild(header);
            carryOverTasks.forEach((task) => renderTaskItem(task, true));
          }

          globalTasks.forEach((task) => renderTaskItem(task, false));

          const active = globalTasks.filter(t => !t.done).length + carryOverTasks.filter(t => !t.done).length;
          countDisplay.innerText = `${active} ACTIVE`;
          if (carryOverTasks.length === 0 && globalTasks.length === 0) {
            const empty = document.createElement("div");
            empty.style.padding = "16px";
            empty.style.color = "var(--accent-color)";
            empty.style.opacity = "0.7";
            empty.style.fontSize = "11px";
            empty.style.textAlign = "center";
            empty.textContent = "등록된 할 일이 없습니다.\n위에서 추가해보세요.";
            empty.style.whiteSpace = "pre";
            list.appendChild(empty);
          }
        }



function startEdit(id, isCarryOver) {
  editingId = id;
  editingCarryOver = isCarryOver;
  renderList();
}

function cancelEdit() {
  editingId = null;
  editingCarryOver = false;
  renderList();
}

async function saveEdit() {
  const inp = document.getElementById("editInput");
  const newText = inp ? inp.value.trim() : "";
  if (!newText || !editingId) { cancelEdit(); return; }
  const today = getTodayISO();
  const yesterday = getYesterdayISO();
  let task = globalTasks.find(t => t.id === editingId);
  if (!task && editingCarryOver) task = carryOverTasks.find(t => t.id === editingId);
  if (!task) { cancelEdit(); return; }

  task.text = newText;
  if (OFFLINE_MODE) {
    if (editingCarryOver) {
      const arr = getOfflineTasks(yesterday).map(t => t.id === editingId ? { ...t, text: newText } : t);
      setOfflineTasks(yesterday, arr);
    } else {
      const arr = getOfflineTasks(today).map(t => t.id === editingId ? { ...t, text: newText } : t);
      setOfflineTasks(today, arr);
    }
    saveLocalTasks();
    editingId = null;
    editingCarryOver = false;
    renderList();
    bc.postMessage({ type: "TASKS_UPDATED" });
    return;
  }

  if (String(editingId).startsWith("temp-")) {
    cancelEdit();
    renderList();
    return;
  }

  inFlight++;
  try {
    const res = await fetch("/api/notion", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ action: "update", pageId: editingId, text: newText })
    });
    const data = await res.json().catch(() => null);
    if (data?.success) {
      saveLocalTasks();
      bc.postMessage({ type: "TASKS_UPDATED" });
    }
  } catch (e) { console.error(e); }
  finally { inFlight--; }
  editingId = null;
  editingCarryOver = false;
  renderList();
}

async function addTask() {
  const text = input.value.trim();
  if (!text) return;

  const today = getTodayISO();
  const newId = OFFLINE_MODE ? 'off-' + Date.now() : 'temp-' + Date.now();
  const newTask = { id: newId, text, done: false, date: today, isSynced: OFFLINE_MODE, createdAt: Date.now(), pending: !OFFLINE_MODE };
  globalTasks.unshift(newTask);

  if (!OFFLINE_MODE) {
    try{
      const pending = JSON.parse(localStorage.getItem(PENDING_KEY) || "{}");
      (pending[today] ||= []).unshift(newTask);
      localStorage.setItem(PENDING_KEY, JSON.stringify(pending));
    }catch(_){}
  }

  bc.postMessage({ type: "TASK_ADDED", task: newTask });
  saveLocalTasks();
  input.value = "";
  renderList();

  if (OFFLINE_MODE) {
    bc.postMessage({ type: "TASKS_UPDATED" });
    return;
  }

  inFlight++;
  try {
    const res = await fetch('/api/notion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'create', text, date: today })
    });

    if (!res.ok) {
      console.error("CREATE HTTP error:", res.status);
      return; // temp 유지(네트워크 회복 후 sync로 정리)
    }

    const data = await res.json().catch(() => null);
    if (!data?.success || !data?.id) {
      console.error("CREATE payload error:", data);
      return;
    }

    const target = globalTasks.find(t => t.id === newId);

        if (target) {
          target.id = data.id;
            
            // ✅ pending 저장소에서도 tempId -> realId로 교체(유령 pending 방지)
try{
  const pending = JSON.parse(localStorage.getItem(PENDING_KEY) || "{}");
  const arr = Array.isArray(pending[today]) ? pending[today] : [];
  pending[today] = arr.map(p => (p && p.id === newId) ? { ...p, id: data.id } : p);
  localStorage.setItem(PENDING_KEY, JSON.stringify(pending));
}catch(_){}
            
          target.isSynced = true;
        
          // ✅ 서버 fetch에 잡힐 때까지 보호
          target.pending = true;
          target.createdAt = Date.now();
        
          saveLocalTasks();
        
          // ✅ IMPORTANT: onclick에 박혀있는 temp-id를 real-id로 갱신하려면 리렌더 필수
          renderList();
        
          bc.postMessage({ type: "TASKS_UPDATED" });
          return;
        }

    // temp를 이미 지운 경우: 서버에서 바로 archive
    if (deletedIds.has(newId)) {
      deletedIds.add(data.id);
      await fetch('/api/notion', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'delete', pageId: data.id })
      });
    }

    bc.postMessage({ type: "TASKS_UPDATED" });
  } catch (e) {
    console.error(e);
  } finally {
    inFlight--; // ✅ 반드시 내려주기
  }
}



async function toggleTask(id, done, isCarryOver) {
  let task = globalTasks.find(t => t.id === id);
  if (!task && isCarryOver) task = carryOverTasks.find(t => t.id === id);
  if (!task) return;

  const nextDone = !done;

  // ✅ temp/off 작업: 로컬만 반영 (API 없이 동작)
  if (String(id).startsWith('temp-') || OFFLINE_MODE) {
    task.done = nextDone;
    if (!OFFLINE_MODE) patchPendingDone(getTodayISO(), { id, text: task.text }, nextDone);
    saveLocalTasks();
    renderList();
    bc.postMessage({ type: "TASKS_UPDATED" });
    return;
  }

  // ✅ optimistic UI
  task.done = nextDone;
  renderList();
  patchPendingDone(getTodayISO(), { id, text: task.text }, nextDone);

  inFlight++;
  try {
    const r = await fetch('/api/notion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'update', pageId: id, done: nextDone })
    });

    if (!r.ok) {
      console.error("UPDATE HTTP error:", r.status);
      task.done = done;
      patchPendingDone(getTodayISO(), { id, text: task.text }, done);
      renderList();
      return;
    }

    const j = await r.json().catch(() => null);
    if (!j?.success) {
      console.error("UPDATE payload error:", j);
      task.done = done;
      patchPendingDone(getTodayISO(), { id, text: task.text }, done);
      renderList();
      return;
    }

    bc.postMessage({ type: "TASKS_UPDATED" });
  } catch (e) {
    console.error(e);
    task.done = done;
    patchPendingDone(getTodayISO(), { id, text: task.text }, done);
    renderList();
  } finally {
    inFlight--;
  }
}


async function deleteTask(id, isCarryOver) {
  deleteArmedId = null;
  const today = getTodayISO();
  let target = globalTasks.find(t => t.id === id);
  if (!target && isCarryOver) target = carryOverTasks.find(t => t.id === id);
  const targetText = target?.text;

  removeFromPending(today, { id, text: targetText });
  if (String(id).startsWith("temp-") && targetText) {
    removeFromPending(today, { id: "__nope__", text: targetText });
  }

  globalTasks = globalTasks.filter(t => t.id !== id);
  carryOverTasks = carryOverTasks.filter(t => t.id !== id);
  saveLocalTasks();
  deletedIds.add(id);
  if (!OFFLINE_MODE) localStorage.setItem(DELETED_KEY, JSON.stringify([...deletedIds]));
  renderList();
  bc.postMessage({ type: "TASKS_UPDATED" });

  if (OFFLINE_MODE) return;
  if (!String(id).startsWith('temp-')) {
    try {
      const r = await fetch('/api/notion', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'delete', pageId: id })
      });
      const j = await r.json().catch(() => ({}));
      if (!r.ok) console.error("DELETE failed:", r.status, j);
    } catch (e) { console.error("DELETE error:", e); }
  }
}

let undoPostponeData = null;
let undoToastTimer = null;

async function postponeTask(id, taskDate) {
  if (String(id).startsWith('temp-')) return;
  const originalDate = taskDate || getTodayISO();
  const nextDate = getNextDayISO(originalDate);

  const task = globalTasks.find(t => t.id === id) || carryOverTasks.find(t => t.id === id);
  if (!task) return;

  if (OFFLINE_MODE) {
    const prevArr = getOfflineTasks(originalDate).filter(t => t.id !== id);
    const nextArr = getOfflineTasks(nextDate);
    nextArr.unshift({ ...task, date: nextDate, done: task.done });
    setOfflineTasks(originalDate, prevArr);
    setOfflineTasks(nextDate, nextArr);
    globalTasks = globalTasks.filter(t => t.id !== id);
    carryOverTasks = carryOverTasks.filter(t => t.id !== id);
    renderList();
    bc.postMessage({ type: "TASKS_UPDATED" });
    undoPostponeData = { id, originalDate, task: { ...task, date: originalDate } };
    const toast = document.getElementById("undoToast");
    if (toast) {
      toast.innerHTML = '다음 날로 미뤘어요. <button type="button" class="btn-undo" onclick="undoPostpone()">되돌리기</button>';
      toast.style.display = "flex";
    }
    if (undoToastTimer) clearTimeout(undoToastTimer);
    undoToastTimer = setTimeout(() => { undoPostponeData = null; if (toast) toast.style.display = "none"; }, 5000);
    return;
  }

  inFlight++;
  try {
    const r = await fetch('/api/notion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'update', pageId: id, newDate: nextDate })
    });
    const j = await r.json().catch(() => null);
    if (!r.ok || !j?.success) {
      console.error("POSTPONE failed:", r.status, j);
      return;
    }
    globalTasks = globalTasks.filter(t => t.id !== id);
    carryOverTasks = carryOverTasks.filter(t => t.id !== id);
    saveLocalTasks();
    renderList();
    bc.postMessage({ type: "TASKS_UPDATED" });

    // ✅ 되돌리기 토스트 (5초간)
    if (undoToastTimer) clearTimeout(undoToastTimer);
    undoPostponeData = { id, originalDate, task: { ...task, date: originalDate } };
    const toast = document.getElementById("undoToast");
    if (toast) {
      toast.innerHTML = '다음 날로 미뤘어요. <button type="button" class="btn-undo" onclick="undoPostpone()">되돌리기</button>';
      toast.style.display = "flex";
    }
    undoToastTimer = setTimeout(() => {
      undoPostponeData = null;
      if (toast) toast.style.display = "none";
    }, 5000);
  } catch (e) {
    console.error("postponeTask error:", e);
  } finally {
    inFlight--;
  }
}

async function undoPostpone() {
  if (!undoPostponeData) return;
  const { id, originalDate, task } = undoPostponeData;
  undoPostponeData = null;
  const toast = document.getElementById("undoToast");
  if (toast) toast.style.display = "none";
  if (undoToastTimer) { clearTimeout(undoToastTimer); undoToastTimer = null; }

  if (OFFLINE_MODE) {
    const nextDate = getNextDayISO(originalDate);
    const nextArr = getOfflineTasks(nextDate).filter(t => t.id !== id);
    const origArr = getOfflineTasks(originalDate);
    origArr.unshift({ ...task, date: originalDate });
    setOfflineTasks(nextDate, nextArr);
    setOfflineTasks(originalDate, origArr);
    const today = getTodayISO();
    const yesterday = getYesterdayISO();
    if (originalDate === today) globalTasks.unshift({ ...task, date: originalDate, isSynced: true });
    else if (originalDate === yesterday) carryOverTasks.push({ ...task, date: originalDate, isSynced: true });
    renderList();
    bc.postMessage({ type: "TASKS_UPDATED" });
    return;
  }

  inFlight++;
  try {
    const r = await fetch('/api/notion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'update', pageId: id, newDate: originalDate })
    });
    const j = await r.json().catch(() => null);
    if (!r.ok || !j?.success) {
      console.error("UNDO POSTPONE failed:", r.status, j);
      return;
    }
    const today = getTodayISO();
    const yesterday = getYesterdayISO();
    if (originalDate === today) {
      globalTasks.unshift({ ...task, date: originalDate, isSynced: true });
    } else if (originalDate === yesterday) {
      carryOverTasks.push({ ...task, date: originalDate, isSynced: true });
    }
    saveLocalTasks();
    renderList();
    bc.postMessage({ type: "TASKS_UPDATED" });
  } catch (e) {
    console.error("undoPostpone error:", e);
  } finally {
    inFlight--;
  }
}

    input.addEventListener("keypress", (e) => { if (e.key === "Enter") addTask(); });
    
    reconcileDayBoundary();
    setInterval(reconcileDayBoundary, 60000);
    
    if (OFFLINE_MODE) {
      document.getElementById("offlineBadge").style.display = "inline";
    }
    if (!OFFLINE_MODE) loadLocalTasks();
    renderList();
    syncFromNotion();
    setInterval(syncFromNotion, 5000);
    </script>
</body>
</html>
