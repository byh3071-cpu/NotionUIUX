<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>schedule</title>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen&family=Noto+Sans+KR:wght@700&display=swap" rel="stylesheet">
    <style>
        /* todo.html과 동일한 디자인 */
        :root { --bg-color: #0f1115; --border-color: #3b4261; --accent-color: #82aaff; --text-color: #dbe6f5; --dim-color: #1e222a; }
        body { margin: 0; padding: 0; background-color: var(--bg-color); font-family: 'Silkscreen', cursive; width: 100vw; height: 100vh; overflow: hidden; color: var(--text-color); }
        .schedule-container { width: 100%; height: 100%; border: 2px solid var(--border-color); box-sizing: border-box; display: flex; flex-direction: column; }
        .header-bar { height: 32px; flex-shrink: 0; border-bottom: 1px solid var(--border-color); background: rgba(59, 66, 97, 0.2); display: flex; align-items: center; justify-content: space-between; padding: 0 12px; font-size: 11px; color: var(--accent-color); }
        .header-left { display: flex; align-items: center; gap: 8px; }
        .input-area { height: 40px; flex-shrink: 0; border-bottom: 2px solid var(--border-color); display: flex; background: rgba(130, 170, 255, 0.05); }
        input, select { background: transparent; border: none; color: #ffffff; font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700; padding: 0 12px; outline: none; }
        input::placeholder { font-family: 'Silkscreen'; color: var(--accent-color); opacity: 0.5; font-size: 11px; font-weight: 400; }
        .input-title { flex: 1; }
        .input-date { width: 110px; border-left: 1px solid var(--border-color); }
        .input-time { width: 70px; border-left: 1px solid var(--border-color); }
        .input-time-end { width: 70px; border-left: 1px solid var(--border-color); }
        .btn-add { width: 40px; background: transparent; border: none; border-left: 1px solid var(--border-color); color: var(--accent-color); cursor: pointer; font-size: 18px; font-family: 'Silkscreen'; }
        .btn-add:hover { background: rgba(130, 170, 255, 0.2); color: #fff; }
        .schedule-list { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .schedule-list::-webkit-scrollbar { width: 4px; }
        .schedule-list::-webkit-scrollbar-track { background: var(--bg-color); }
        .schedule-list::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }
        .schedule-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border: 1px solid var(--border-color); background: rgba(30, 34, 42, 0.4); transition: all 0.2s; }
        .schedule-item:hover { border-color: var(--accent-color); background: rgba(30, 34, 42, 0.8); transform: translateX(2px); }
        .schedule-left { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
        .schedule-marker { width: 12px; height: 12px; border: 2px solid var(--accent-color); flex-shrink: 0; background: rgba(130, 170, 255, 0.2); }
        .text-content { font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700; color: #ffffff; line-height: 1.2; letter-spacing: -0.3px; padding-top: 2px; word-break: break-word; }
        .text-meta { font-size: 10px; color: var(--accent-color); opacity: 0.8; margin-top: 2px; }
        .btn-action { color: #4c566a; cursor: pointer; padding: 4px 6px; opacity: 0.8; font-family: 'Silkscreen'; font-size: 10px; background: transparent; border: 1px solid var(--border-color); min-width: 24px; display: flex; align-items: center; justify-content: center; }
        .btn-action:hover { opacity: 1; }
        .btn-edit { color: #82aaff; }
        .btn-edit:hover { border-color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .btn-delete { color: #4c566a; }
        .btn-delete:hover { color: #ff5370; border-color: #ff5370; }
        .schedule-item-actions { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }
        .schedule-item.is-temp { opacity: 0.7; border-style: dashed; }
        .schedule-item.is-past { opacity: 0.6; }
        .schedule-item.is-past .text-content { color: #888; }
        .filter-bar { display: flex; align-items: center; gap: 6px; padding: 6px 10px; border-bottom: 1px solid var(--border-color); background: rgba(59, 66, 97, 0.15); flex-shrink: 0; }
        .filter-chip { padding: 4px 8px; font-size: 9px; border: 1px solid var(--border-color); background: transparent; color: var(--text-color); cursor: pointer; font-family: 'Silkscreen'; }
        .filter-chip:hover { border-color: var(--accent-color); }
        .filter-chip.active { border-color: var(--accent-color); color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .section-header { font-size: 10px; color: var(--accent-color); opacity: 0.9; padding: 6px 10px 4px; border-bottom: 1px dashed var(--border-color); margin-top: 8px; }
        .section-header:first-child { margin-top: 0; }
    </style>
</head>
<body>
    <div class="schedule-container">
        <div class="header-bar">
            <span class="header-left">
                <span>schedule<span id="offlineBadge" style="display:none; margin-left:6px; font-size:9px; color:#ffa94d;">[테스트]</span></span>
                <span id="event-count">LOADING...</span>
            </span>
            <span id="syncStatus" style="font-size:8px; opacity:0.8;" title="동기화 상태">—</span>
        </div>
        <div class="filter-bar">
            <button class="filter-chip active" data-filter="today">오늘</button>
            <button class="filter-chip" data-filter="7day">7일</button>
            <button class="filter-chip" data-filter="30day">한달</button>
            <button class="filter-chip" data-filter="all">전체</button>
            <label style="margin-left:auto; font-size:9px; cursor:pointer; display:flex; align-items:center; gap:4px;">
                <input type="checkbox" id="showPast" style="width:12px; height:12px; accent-color:var(--accent-color);">
                지난 일정
            </label>
        </div>
        <div class="input-area">
            <input type="text" id="inputTitle" class="input-title" placeholder="> schedule..." autocomplete="off" title="Enter로 추가">
            <input type="date" id="inputDate" class="input-date" title="날짜 선택">
            <input type="time" id="inputTimeStart" class="input-time" title="시작 시간 (24시간)" step="300">
            <input type="time" id="inputTimeEnd" class="input-time-end" title="종료 시간 (24시간)" step="300">
            <button class="btn-add" onclick="addEvent()" title="schedule (Enter)">+</button>
        </div>
        <div class="schedule-list" id="list"></div>
    </div>

<script>
    const inputTitle = document.getElementById("inputTitle");
    const inputDate = document.getElementById("inputDate");
    const inputTimeStart = document.getElementById("inputTimeStart");
    const inputTimeEnd = document.getElementById("inputTimeEnd");
    const list = document.getElementById("list");
    const showPastCheck = document.getElementById("showPast");

    let viewFilter = "today";

    function getDateOffset(iso, days) {
        const datePart = String(iso || "").slice(0, 10);
        const parts = datePart.split("-");
        if (parts.length < 3) return getTodayISO();
        const [y, m, d] = parts.map(Number);
        const d2 = new Date(y, m - 1, d);
        if (isNaN(d2.getTime())) return getTodayISO();
        d2.setDate(d2.getDate() + days);
        return d2.toLocaleDateString("sv-SE", { timeZone: "Asia/Seoul" });
    }
    const countDisplay = document.getElementById("event-count");

    const OFFLINE_MODE = window.location.search.includes('offline=1');
    const OFFLINE_EVENTS_KEY = "missionlog_offline_events_v1";
    function loadOfflineEvents(){ try{ return JSON.parse(localStorage.getItem(OFFLINE_EVENTS_KEY)) || []; }catch(_){ return []; } }
    function saveOfflineEvents(arr){ localStorage.setItem(OFFLINE_EVENTS_KEY, JSON.stringify(arr)); }

    let globalEvents = [];
    let inFlight = 0;

    const bc = new BroadcastChannel("missionlog_bus_v1");
    let _bcTimer = null;
    bc.onmessage = (ev) => {
        if (ev?.data?.type !== "EVENTS_UPDATED" && ev?.data?.type !== "TASKS_UPDATED") return;
        clearTimeout(_bcTimer);
        _bcTimer = setTimeout(syncFromNotion, 150);
    };

    const PENDING_EVENTS_KEY = "missionlog_pendingEvents_v1";
    function loadPendingEventsMap(){ try{ const o = JSON.parse(localStorage.getItem(PENDING_EVENTS_KEY) || "{}"); return (o && typeof o === "object") ? o : {}; }catch(_){ return {}; } }
    function savePendingEventsMap(obj){ localStorage.setItem(PENDING_EVENTS_KEY, JSON.stringify(obj)); }
    function getAllPendingEvents(){ const m = loadPendingEventsMap(); return Object.values(m).flat().filter(Boolean); }

    const LOCAL_EVENTS_KEY = "missionlog_localEvents_v1";

    function getTodayISO() {
        return new Date().toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
    }

    function getTodayInput() {
        const d = new Date();
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
    }

    /** 24시간 HH:mm → "오전 09:00" 또는 "오후 15:00" (오전 0~11시, 오후 12~23시) */
    function formatTimeWithAmPm(hhmm) {
        if (!hhmm) return "";
        const [h, m] = hhmm.split(":").map(Number);
        const hour = h ?? 0;
        const prefix = hour < 12 ? "오전" : "오후";
        return `${prefix} ${String(hour).padStart(2, "0")}:${String(m || 0).padStart(2, "0")}`;
    }

    /** ISO 문자열에서 HH:mm 추출 */
    function extractHHmm(iso) {
        if (!iso) return "";
        const m = String(iso).match(/T(\d{2}:\d{2})/);
        return m ? m[1] : "";
    }

    /** 일정 시간 범위 표시: "오후 15:00~17:00" 또는 "오전 09:00~오후 15:00" (24시간 기준) */
    function formatTimeRangeForDisplay(startISO, endISO) {
        const startHhmm = extractHHmm(startISO);
        const endHhmm = extractHHmm(endISO);
        if (!startHhmm && !endHhmm) return "";
        if (!endHhmm) return formatTimeWithAmPm(startHhmm);
        const startH = parseInt(startHhmm.split(":")[0], 10) || 0;
        const endH = parseInt(endHhmm.split(":")[0], 10) || 0;
        const sameHalf = (startH < 12) === (endH < 12);
        if (sameHalf) {
            const prefix = startH < 12 ? "오전" : "오후";
            return `${prefix} ${startHhmm}~${endHhmm}`;
        }
        return `${formatTimeWithAmPm(startHhmm)}~${formatTimeWithAmPm(endHhmm)}`;
    }

    function toISODateTime(dateStr, timeStr) {
        if (!dateStr) return null;
        const base = dateStr + "T" + (timeStr || "00:00") + ":00";
        return base + "+09:00";
    }

    const syncStatusEl = document.getElementById("syncStatus");
    function setSyncStatus(txt) { if (syncStatusEl) syncStatusEl.textContent = txt; }

    function loadLocalEvents() {
        try {
            const arr = JSON.parse(localStorage.getItem(LOCAL_EVENTS_KEY) || "[]");
            if (Array.isArray(arr)) globalEvents = arr;
        } catch(_) {}
    }

    function saveLocalEvents() {
        try {
            if (OFFLINE_MODE) {
                saveOfflineEvents(globalEvents);
                return;
            }
            localStorage.setItem(LOCAL_EVENTS_KEY, JSON.stringify(globalEvents));
        } catch(_) {}
    }

    async function syncFromNotion() {
        if (inFlight > 0) return;
        if (OFFLINE_MODE) {
            setSyncStatus("테스트");
            globalEvents = loadOfflineEvents();
            saveLocalEvents();
            renderList();
            return;
        }

        try {
            setSyncStatus("동기화중");
            const d = new Date();
            d.setMonth(d.getMonth() - 1);
            const from = d.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
            d.setMonth(d.getMonth() + 3);
            const to = d.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });

            const res = await fetch('/api/notion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'fetch', from, to })
            });
            const data = await res.json();
            if (!res.ok || !data?.success) { setSyncStatus("실패"); renderList(); return; }

            const serverEvents = (data.events || []).map(e => ({
                ...e,
                start: e.start || "",
                end: e.end || ""
            }));

            const pendingMap = loadPendingEventsMap();
            const serverByISO = {};
            serverEvents.forEach(e => {
                const iso = String(e.start || "").slice(0, 10);
                if (iso) (serverByISO[iso] ||= []).push(e);
            });
            for (const iso of Object.keys(pendingMap)) {
                const arr = Array.isArray(pendingMap[iso]) ? pendingMap[iso] : [];
                pendingMap[iso] = arr.filter(p => !(serverByISO[iso] || []).some(s =>
                    (p.id && s.id && p.id === s.id) ||
                    (String(p.start || "").slice(0,16) === String(s.start || "").slice(0,16) && (p.title || "") === (s.title || ""))
                ));
                if (pendingMap[iso].length === 0) delete pendingMap[iso];
            }
            savePendingEventsMap(pendingMap);
            const pendingFiltered = getAllPendingEvents();
            globalEvents = [...serverEvents, ...pendingFiltered].sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));
            saveLocalEvents();
            setSyncStatus("완료");
            renderList();
        } catch (err) {
            console.error(err);
            setSyncStatus("실패");
            renderList();
        }
    }

    function renderList() {
        list.innerHTML = "";
        const esc = (s) => String(s || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;");
        const escId = (id) => String(id || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'");

        const today = getTodayISO();
        const showPast = showPastCheck ? showPastCheck.checked : false;

        let filtered = globalEvents.filter(e => {
            const dateStr = String(e.start || e.date || "").slice(0, 10);
            if (!dateStr) return false;
            const isPast = dateStr < today;
            if (!showPast && isPast) return false;
            if (viewFilter === "today") return dateStr === today;
            if (viewFilter === "7day") return dateStr >= today && dateStr <= getDateOffset(today, 7);
            if (viewFilter === "30day") return dateStr >= today && dateStr <= getDateOffset(today, 30);
            return true;
        }).sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));

        const displayEvents = filtered.slice(0, 80);

        const groupByDate = {};
        displayEvents.forEach(ev => {
            const ds = String(ev.start || ev.date || "").slice(0, 10) || today;
            (groupByDate[ds] ||= []).push(ev);
        });

        const labels = { [today]: "오늘" };
        const tomorrow = getDateOffset(today, 1);
        labels[tomorrow] = "내일";

        const sortedDates = Object.keys(groupByDate).sort();
        sortedDates.forEach(dateStr => {
            const evs = groupByDate[dateStr];
            const isPastDate = dateStr < today;
            const label = labels[dateStr] || dateStr;
            if (isPastDate && sortedDates.indexOf(dateStr) === sortedDates.findIndex(d => d < today)) {
                const pastHeader = document.createElement("div");
                pastHeader.className = "section-header";
                pastHeader.textContent = "지난 일정";
                list.appendChild(pastHeader);
            }
            const header = document.createElement("div");
            header.className = "section-header";
            header.textContent = label;
            list.appendChild(header);
            evs.forEach(ev => {
                const evDateStr = String(ev.start || ev.date || "").slice(0,10) || today;
                const isPast = evDateStr < today;
                const div = document.createElement("div");
                div.className = `schedule-item ${String(ev.id || "").startsWith("temp-") || String(ev.id || "").startsWith("off-") ? "is-temp" : ""} ${isPast ? "is-past" : ""}`;
                const timeStr = formatTimeRangeForDisplay(ev.start, ev.end);
                const meta = timeStr ? `${evDateStr} ${timeStr}` : evDateStr;
                div.innerHTML = `
                    <div class="schedule-left">
                        <div class="schedule-marker"></div>
                        <div>
                            <span class="text-content">${esc(ev.title || "schedule")}</span>
                            <div class="text-meta">${meta}</div>
                        </div>
                    </div>
                    <div class="schedule-item-actions">
                        <button type="button" class="btn-action btn-delete" title="삭제" onclick="event.stopPropagation(); deleteEvent('${escId(ev.id)}'); return false;">X</button>
                    </div>
                `;
                list.appendChild(div);
            });
        });

        if (countDisplay) countDisplay.innerText = `${displayEvents.length} SCHEDULED`;

        if (displayEvents.length === 0) {
            const empty = document.createElement("div");
            empty.style.padding = "16px";
            empty.style.color = "var(--accent-color)";
            empty.style.opacity = "0.7";
            empty.style.fontSize = "11px";
            empty.style.textAlign = "center";
            empty.textContent = "No schedule yet.\nAdd one above.";
            empty.style.whiteSpace = "pre";
            list.appendChild(empty);
        }
    }

    async function addEvent() {
        const title = inputTitle.value.trim();
        if (!title) return;

        const dateStr = inputDate.value || getTodayInput();
        const timeStart = inputTimeStart.value || "";
        const timeEnd = inputTimeEnd.value || "";
        const startISO = toISODateTime(dateStr, timeStart || "00:00");
        if (!startISO) return;

        const endISO = (timeStart || timeEnd) ? toISODateTime(dateStr, timeEnd || timeStart) : null;

        const today = getTodayISO();
        const newId = OFFLINE_MODE ? 'off-' + Date.now() : 'temp-' + Date.now();
        const newEvent = {
            id: newId,
            title,
            start: startISO,
            end: endISO,
            date: dateStr,
            isSynced: OFFLINE_MODE,
            pending: !OFFLINE_MODE
        };
        globalEvents.push(newEvent);
        globalEvents.sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));

        if (!OFFLINE_MODE) {
            const pendingMap = loadPendingEventsMap();
            (pendingMap[dateStr] ||= []).unshift(newEvent);
            savePendingEventsMap(pendingMap);
        }

        bc.postMessage({ type: "EVENT_ADDED", event: newEvent });
        saveLocalEvents();
        inputTitle.value = "";
        inputDate.value = getTodayInput();
        inputTimeStart.value = "";
        inputTimeEnd.value = "";
        renderList();

        if (OFFLINE_MODE) {
            bc.postMessage({ type: "EVENTS_UPDATED" });
            return;
        }

        inFlight++;
        try {
            const res = await fetch('/api/notion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'createEvent', title, start: startISO, end: endISO })
            });

            if (!res.ok) {
                console.error("CREATE EVENT HTTP error:", res.status);
                setSyncStatus("생성 실패");
                renderList();
                return;
            }

            const data = await res.json().catch(() => null);
            if (!data?.success || !data?.id) {
                console.error("CREATE EVENT payload error:", data);
                setSyncStatus("생성 실패");
                renderList();
                return;
            }

            const target = globalEvents.find(e => e.id === newId);
            if (target) {
                target.id = data.id;
                target.isSynced = true;
                target.pending = true;
                const pendingMap = loadPendingEventsMap();
                for (const iso of Object.keys(pendingMap)) {
                    const idx = (pendingMap[iso] || []).findIndex(p => p.id === newId);
                    if (idx >= 0) { pendingMap[iso][idx] = { ...pendingMap[iso][idx], id: data.id }; break; }
                }
                savePendingEventsMap(pendingMap);
                saveLocalEvents();
                renderList();
                bc.postMessage({ type: "EVENTS_UPDATED" });
            }
        } catch (e) {
            console.error(e);
            setSyncStatus("네트워크 오류");
            renderList();
        } finally {
            inFlight--;
        }
    }

    async function deleteEvent(id) {
        const target = globalEvents.find(e => e.id === id);
        globalEvents = globalEvents.filter(e => e.id !== id);
        const pendingMap = loadPendingEventsMap();
        for (const iso of Object.keys(pendingMap)) {
            pendingMap[iso] = (pendingMap[iso] || []).filter(p => p.id !== id);
            if (pendingMap[iso].length === 0) delete pendingMap[iso];
        }
        savePendingEventsMap(pendingMap);
        saveLocalEvents();
        renderList();
        bc.postMessage({ type: "EVENTS_UPDATED" });

        if (OFFLINE_MODE) return;
        if (!target) return;
        if (!String(id).startsWith('temp-') && !String(id).startsWith('off-')) {
            try {
                await fetch('/api/notion', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'deleteEvent', pageId: id })
                });
            } catch (e) { console.error("DELETE EVENT error:", e); }
        }
    }

    inputTitle.addEventListener("keypress", (e) => { if (e.key === "Enter") addEvent(); });

    document.querySelectorAll(".filter-chip").forEach(btn => {
        btn.addEventListener("click", () => {
            viewFilter = btn.dataset.filter;
            document.querySelectorAll(".filter-chip").forEach(b => b.classList.toggle("active", b === btn));
            renderList();
        });
    });
    if (showPastCheck) showPastCheck.addEventListener("change", renderList);

    if (OFFLINE_MODE) document.getElementById("offlineBadge").style.display = "inline";
    inputDate.value = getTodayInput();
    loadLocalEvents();
    renderList();
    syncFromNotion();
    setInterval(syncFromNotion, 5000);
</script>
</body>
</html>
