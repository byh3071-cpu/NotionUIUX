<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>schedule</title>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen&family=Noto+Sans+KR:wght@700&display=swap" rel="stylesheet">
    <style>
        /* todo.html과 동일한 디자인 */
        :root { --bg-color: #0f1115; --border-color: #3b4261; --accent-color: #82aaff; --text-color: #dbe6f5; --dim-color: #1e222a; }
        body { margin: 0; padding: 0; background-color: var(--bg-color); font-family: 'Silkscreen', cursive; width: 100vw; height: 100vh; overflow: hidden; color: var(--text-color); }
        .schedule-container { width: 100%; height: 100%; border: 2px solid var(--border-color); box-sizing: border-box; display: flex; flex-direction: column; }
        .header-bar { height: 32px; flex-shrink: 0; border-bottom: 1px solid var(--border-color); background: rgba(59, 66, 97, 0.2); display: flex; align-items: center; justify-content: space-between; padding: 0 12px; font-size: 11px; color: var(--accent-color); }
        .header-left { display: flex; align-items: center; gap: 8px; }
        .input-area { height: 40px; flex-shrink: 0; border-bottom: 2px solid var(--border-color); display: flex; background: rgba(130, 170, 255, 0.05); }
        input, select { background: transparent; border: none; color: #ffffff; font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700; padding: 0 12px; outline: none; }
        input::placeholder { font-family: 'Silkscreen'; color: var(--accent-color); opacity: 0.5; font-size: 11px; font-weight: 400; }
        .input-title { flex: 1; }
        .input-datetime { width: 44px; min-width: 44px; border-left: 1px solid var(--border-color); flex-shrink: 0; }
        .btn-add { width: 40px; background: transparent; border: none; border-left: 1px solid var(--border-color); color: var(--accent-color); cursor: pointer; font-size: 18px; font-family: 'Silkscreen'; }
        .btn-add:hover { background: rgba(130, 170, 255, 0.2); color: #fff; }
        .schedule-list { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .schedule-list::-webkit-scrollbar { width: 4px; }
        .schedule-list::-webkit-scrollbar-track { background: var(--bg-color); }
        .schedule-list::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }
        .schedule-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border: 1px solid var(--border-color); background: rgba(30, 34, 42, 0.4); transition: all 0.2s; }
        .schedule-item.is-editing { flex-direction: column; align-items: stretch; gap: 10px; }
        .schedule-item.is-editing .schedule-left { flex-direction: column; align-items: stretch; }
        .edit-picker { background: #0e1016; border: 1px solid var(--border-color); padding: 10px; margin-top: 4px; }
        .schedule-item:hover { border-color: var(--accent-color); background: rgba(30, 34, 42, 0.8); transform: translateX(2px); }
        .schedule-left { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
        .schedule-marker { width: 12px; height: 12px; border: 2px solid var(--accent-color); flex-shrink: 0; background: rgba(130, 170, 255, 0.2); }
        .text-content { font-family: 'Noto Sans KR', sans-serif; font-size: 12px; font-weight: 700; color: #ffffff; line-height: 1.2; letter-spacing: -0.3px; padding-top: 2px; word-break: break-word; }
        .text-meta { font-size: 10px; color: var(--accent-color); opacity: 0.8; margin-top: 2px; }
        .btn-action { color: #4c566a; cursor: pointer; padding: 4px 6px; opacity: 0.8; font-family: 'Silkscreen'; font-size: 10px; background: transparent; border: 1px solid var(--border-color); min-width: 24px; display: flex; align-items: center; justify-content: center; }
        .btn-action:hover { opacity: 1; }
        .btn-edit { color: #82aaff; }
        .btn-edit:hover { border-color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .btn-delete { color: #4c566a; }
        .btn-delete:hover { color: #ff5370; border-color: #ff5370; }
        .schedule-item-actions { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }
        .schedule-item.is-temp { opacity: 0.7; border-style: dashed; }
        .schedule-item.is-past { opacity: 0.6; }
        .schedule-item.is-past .text-content { color: #888; }
        .filter-bar { display: flex; align-items: center; gap: 6px; padding: 6px 10px; border-bottom: 1px solid var(--border-color); background: rgba(59, 66, 97, 0.15); flex-shrink: 0; }
        .filter-chip { padding: 4px 8px; font-size: 9px; border: 1px solid var(--border-color); background: transparent; color: var(--text-color); cursor: pointer; font-family: 'Silkscreen'; }
        .filter-chip:hover { border-color: var(--accent-color); }
        .filter-chip.active { border-color: var(--accent-color); color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .section-header { font-size: 10px; color: var(--accent-color); opacity: 0.9; padding: 6px 10px 4px; border-bottom: 1px dashed var(--border-color); margin-top: 8px; }
        .section-header:first-child { margin-top: 0; }

        /* 커스텀 날짜·시간 통합 피커 */
        .dt-picker-wrap { position: relative; border-left: 1px solid var(--border-color); }
        .dt-picker-trigger { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; padding: 0; cursor: pointer; border: none; background: transparent; font-family: inherit; }
        .dt-picker-trigger:hover { background: rgba(130, 170, 255, 0.1); }
        .dt-picker-trigger svg { width: 20px; height: 20px; color: var(--accent-color); }
        .dt-picker-drop { position: absolute; top: 100%; right: 0; left: auto; margin-top: 2px; background: #0e1016; border: 2px solid var(--border-color); box-shadow: 0 4px 20px rgba(0,0,0,.5); z-index: 100; min-width: 240px; padding: 8px; }
        .dt-picker-drop.hidden { display: none; }
        .dt-picker-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .dt-picker-nav { display: flex; gap: 4px; align-items: center; }
        .dt-picker-nav-btn { width: 24px; height: 24px; border: 1px solid var(--border-color); background: #0b0c10; color: var(--text-color); cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; }
        .dt-picker-nav-btn:hover { border-color: var(--accent-color); }
        .dt-picker-month { font-size: 10px; color: var(--text-color); min-width: 70px; text-align: center; }
        .dt-picker-dow { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; margin-bottom: 4px; }
        .dt-picker-dow span { font-size: 8px; color: var(--accent-color); text-align: center; opacity: 0.8; }
        .dt-picker-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; }
        .dt-picker-day { width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer; border: 1px solid transparent; background: transparent; color: var(--text-color); }
        .dt-picker-day:hover { border-color: var(--accent-color); background: rgba(130, 170, 255, 0.15); }
        .dt-picker-day.other { opacity: 0.4; }
        .dt-picker-day.today { border-color: var(--accent-color); font-weight: 700; }
        .dt-picker-day.selected { background: var(--accent-color); color: #0b0c10; }
        .dt-picker-time { display: flex; flex-direction: column; gap: 6px; margin-top: 10px; padding-top: 8px; border-top: 1px solid var(--border-color); }
        .dt-picker-time-row { display: flex; align-items: center; gap: 6px; }
        .dt-picker-time label { font-size: 9px; color: var(--accent-color); min-width: 52px; }
        .dt-picker-time input { width: 36px; padding: 4px 6px; font-size: 11px; color: var(--text-color); background: #0b0c10; border: 1px solid var(--border-color); }
        .dt-picker-now { margin-left: auto; font-size: 9px; color: var(--accent-color); cursor: pointer; }
        .dt-picker-now:hover { text-decoration: underline; }
        /* 편집 모달 - 스크롤 영향 없음 */
        .edit-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; }
        .edit-modal-overlay.hidden { display: none; }
        .edit-modal { background: #0e1016; border: 2px solid var(--border-color); max-width: 280px; width: 100%; max-height: 90vh; overflow-y: auto; padding: 12px; }
    </style>
</head>
<body>
    <div class="schedule-container">
        <div class="header-bar">
            <span class="header-left">
                <span>schedule<span id="offlineBadge" style="display:none; margin-left:6px; font-size:9px; color:#ffa94d;">[테스트]</span></span>
                <span id="event-count">LOADING...</span>
            </span>
            <span id="syncStatus" style="font-size:8px; opacity:0.8;" title="동기화 상태">—</span>
        </div>
        <div class="filter-bar">
            <button class="filter-chip active" data-filter="today">오늘</button>
            <button class="filter-chip" data-filter="7day">7일</button>
            <button class="filter-chip" data-filter="30day">한달</button>
            <button class="filter-chip" data-filter="all">전체</button>
            <label style="margin-left:auto; font-size:9px; cursor:pointer; display:flex; align-items:center; gap:4px;">
                <input type="checkbox" id="showPast" style="width:12px; height:12px; accent-color:var(--accent-color);">
                지난 일정
            </label>
        </div>
        <div class="input-area">
            <input type="text" id="inputTitle" class="input-title" placeholder="> schedule..." autocomplete="off" title="Enter로 추가">
            <div class="input-datetime dt-picker-wrap" id="dt-picker-wrap">
            <input type="hidden" id="inputStart" />
            <button type="button" class="dt-picker-trigger" id="dt-picker-trigger" tabindex="0" title="날짜·시간 선택">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
            </button>
            <div class="dt-picker-drop hidden" id="dt-picker-drop">
                <div class="dt-picker-header">
                    <div class="dt-picker-nav">
                        <button type="button" class="dt-picker-nav-btn" id="dt-prev-month" title="이전 달">‹</button>
                        <span class="dt-picker-month" id="dt-month-label">2026년 2월</span>
                        <button type="button" class="dt-picker-nav-btn" id="dt-next-month" title="다음 달">›</button>
                    </div>
                    <span class="dt-picker-now" id="dt-now">지금</span>
                </div>
                <div class="dt-picker-dow">
                    <span>일</span><span>월</span><span>화</span><span>수</span><span>목</span><span>금</span><span>토</span>
                </div>
                <div class="dt-picker-grid" id="dt-calendar-grid"></div>
                <div class="dt-picker-time">
                    <div class="dt-picker-time-row">
                        <label>시작 시간</label>
                        <input type="number" id="dt-hour" min="0" max="23" value="9" />
                        <span>:</span>
                        <input type="number" id="dt-min" min="0" max="59" value="0" />
                        <span style="font-size: 9px; opacity: 0.8;" id="dt-ampm">오전</span>
                    </div>
                    <div class="dt-picker-time-row">
                        <label>종료 시간</label>
                        <input type="number" id="dt-hour-end" min="0" max="23" value="10" />
                        <span>:</span>
                        <input type="number" id="dt-min-end" min="0" max="59" value="0" />
                        <span style="font-size: 9px; opacity: 0.8;" id="dt-ampm-end">오전</span>
                    </div>
                </div>
            </div>
        </div>
            <input type="hidden" id="inputTimeEnd" />
            <button class="btn-add" onclick="addEvent()" title="schedule (Enter)">+</button>
        </div>
        <div class="schedule-list" id="list"></div>
    </div>
    <div class="edit-modal-overlay hidden" id="editModalOverlay">
        <div class="edit-modal" id="editModal" onclick="event.stopPropagation()"></div>
    </div>

<script>
    const inputTitle = document.getElementById("inputTitle");
    const inputStart = document.getElementById("inputStart");
    const inputTimeEnd = document.getElementById("inputTimeEnd");
    const list = document.getElementById("list");
    const showPastCheck = document.getElementById("showPast");

    let viewFilter = "today";
    let editingEventId = null;
    let editViewYear = new Date().getFullYear();
    let editViewMonth = new Date().getMonth();
    let editPickedDate = null; // { y, m, d }
    let editTimeOverride = null; // { h, m, he, me } when "지금" clicked

    function getEditCalendarGridHTML() {
        const first = new Date(editViewYear, editViewMonth, 1);
        const last = new Date(editViewYear, editViewMonth + 1, 0);
        const startDow = first.getDay();
        const daysInMonth = last.getDate();
        const today = new Date();
        const todayY = today.getFullYear(), todayM = today.getMonth(), todayD = today.getDate();
        let html = "";
        const prevMonth = editViewMonth === 0 ? 11 : editViewMonth - 1;
        const prevYear = editViewMonth === 0 ? editViewYear - 1 : editViewYear;
        const prevLast = new Date(prevYear, prevMonth + 1, 0).getDate();
        for (let i = 0; i < startDow; i++) {
            const d = prevLast - startDow + i + 1;
            html += `<button type="button" class="dt-picker-day other" data-y="${prevYear}" data-m="${prevMonth}" data-d="${d}">${d}</button>`;
        }
        for (let d = 1; d <= daysInMonth; d++) {
            let cls = "dt-picker-day";
            if (editViewYear === todayY && editViewMonth === todayM && d === todayD) cls += " today";
            if (editPickedDate && editPickedDate.y === editViewYear && editPickedDate.m === editViewMonth + 1 && editPickedDate.d === d) cls += " selected";
            html += `<button type="button" class="${cls}" data-y="${editViewYear}" data-m="${editViewMonth}" data-d="${d}">${d}</button>`;
        }
        const nextMonth = editViewMonth === 11 ? 0 : editViewMonth + 1;
        const nextYear = editViewMonth === 11 ? editViewYear + 1 : editViewYear;
        const remaining = 42 - (startDow + daysInMonth);
        for (let d = 1; d <= Math.min(remaining, 14); d++) {
            html += `<button type="button" class="dt-picker-day other" data-y="${nextYear}" data-m="${nextMonth}" data-d="${d}">${d}</button>`;
        }
        return html;
    }

    function getDateOffset(iso, days) {
        const datePart = String(iso || "").slice(0, 10);
        const parts = datePart.split("-");
        if (parts.length < 3) return getTodayISO();
        const [y, m, d] = parts.map(Number);
        const d2 = new Date(y, m - 1, d);
        if (isNaN(d2.getTime())) return getTodayISO();
        d2.setDate(d2.getDate() + days);
        return d2.toLocaleDateString("sv-SE", { timeZone: "Asia/Seoul" });
    }
    const countDisplay = document.getElementById("event-count");

    const OFFLINE_MODE = window.location.search.includes('offline=1');
    const OFFLINE_EVENTS_KEY = "missionlog_offline_events_v1";
    function loadOfflineEvents(){ try{ return JSON.parse(localStorage.getItem(OFFLINE_EVENTS_KEY)) || []; }catch(_){ return []; } }
    function saveOfflineEvents(arr){ localStorage.setItem(OFFLINE_EVENTS_KEY, JSON.stringify(arr)); }

    let globalEvents = [];
    let inFlight = 0;

    const bc = new BroadcastChannel("missionlog_bus_v1");
    let _bcTimer = null;
    bc.onmessage = (ev) => {
        if (ev?.data?.type !== "EVENTS_UPDATED" && ev?.data?.type !== "TASKS_UPDATED") return;
        clearTimeout(_bcTimer);
        _bcTimer = setTimeout(syncFromNotion, 150);
    };

    const PENDING_EVENTS_KEY = "missionlog_pendingEvents_v1";
    function loadPendingEventsMap(){ try{ const o = JSON.parse(localStorage.getItem(PENDING_EVENTS_KEY) || "{}"); return (o && typeof o === "object") ? o : {}; }catch(_){ return {}; } }
    function savePendingEventsMap(obj){ localStorage.setItem(PENDING_EVENTS_KEY, JSON.stringify(obj)); }
    function getAllPendingEvents(){ const m = loadPendingEventsMap(); return Object.values(m).flat().filter(Boolean); }

    const LOCAL_EVENTS_KEY = "missionlog_localEvents_v1";

    function getTodayISO() {
        return new Date().toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
    }

    function getTodayDatetimeLocal() {
        const d = new Date();
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const h = String(d.getHours()).padStart(2, '0');
        const min = String(d.getMinutes()).padStart(2, '0');
        return `${y}-${m}-${day}T${h}:${min}`;
    }
    function datetimeLocalToISO(dtLocal) {
        if (!dtLocal) return null;
        return dtLocal + ":00+09:00";
    }

    /** 24시간 HH:mm → "오전 09:00" 또는 "오후 15:00" (오전 0~11시, 오후 12~23시) */
    function formatTimeWithAmPm(hhmm) {
        if (!hhmm) return "";
        const [h, m] = hhmm.split(":").map(Number);
        const hour = h ?? 0;
        const prefix = hour < 12 ? "오전" : "오후";
        return `${prefix} ${String(hour).padStart(2, "0")}:${String(m || 0).padStart(2, "0")}`;
    }

    /** ISO 문자열에서 HH:mm 추출 */
    function extractHHmm(iso) {
        if (!iso) return "";
        const m = String(iso).match(/T(\d{2}:\d{2})/);
        return m ? m[1] : "";
    }

    /** 일정 시간 범위 표시: "오후 15:00~17:00" 또는 "오전 09:00~오후 15:00" (24시간 기준) */
    function formatTimeRangeForDisplay(startISO, endISO) {
        const startHhmm = extractHHmm(startISO);
        const endHhmm = extractHHmm(endISO);
        if (!startHhmm && !endHhmm) return "";
        if (!endHhmm) return formatTimeWithAmPm(startHhmm);
        const startH = parseInt(startHhmm.split(":")[0], 10) || 0;
        const endH = parseInt(endHhmm.split(":")[0], 10) || 0;
        const sameHalf = (startH < 12) === (endH < 12);
        if (sameHalf) {
            const prefix = startH < 12 ? "오전" : "오후";
            return `${prefix} ${startHhmm}~${endHhmm}`;
        }
        return `${formatTimeWithAmPm(startHhmm)}~${formatTimeWithAmPm(endHhmm)}`;
    }

    function toISODateTime(dateStr, timeStr) {
        if (!dateStr) return null;
        const base = dateStr + "T" + (timeStr || "00:00") + ":00";
        return base + "+09:00";
    }

    const syncStatusEl = document.getElementById("syncStatus");
    function setSyncStatus(txt) { if (syncStatusEl) syncStatusEl.textContent = txt; }

    function loadLocalEvents() {
        try {
            const arr = JSON.parse(localStorage.getItem(LOCAL_EVENTS_KEY) || "[]");
            if (Array.isArray(arr)) globalEvents = arr;
        } catch(_) {}
    }

    function saveLocalEvents() {
        try {
            if (OFFLINE_MODE) {
                saveOfflineEvents(globalEvents);
                return;
            }
            localStorage.setItem(LOCAL_EVENTS_KEY, JSON.stringify(globalEvents));
        } catch(_) {}
    }

    async function syncFromNotion() {
        if (inFlight > 0) return;
        if (editingEventId) return;
        if (OFFLINE_MODE) {
            setSyncStatus("테스트");
            globalEvents = loadOfflineEvents();
            saveLocalEvents();
            renderList();
            return;
        }

        try {
            setSyncStatus("동기화중");
            const d = new Date();
            d.setMonth(d.getMonth() - 1);
            const from = d.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });
            d.setMonth(d.getMonth() + 3);
            const to = d.toLocaleDateString('sv-SE', { timeZone: 'Asia/Seoul' });

            const res = await fetch('/api/notion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'fetch', from, to })
            });
            const data = await res.json();
            if (!res.ok || !data?.success) { setSyncStatus("실패"); renderList(); return; }

            const serverEvents = (data.events || []).map(e => ({
                ...e,
                start: e.start || "",
                end: e.end || ""
            }));

            const pendingMap = loadPendingEventsMap();
            const serverByISO = {};
            serverEvents.forEach(e => {
                const iso = String(e.start || "").slice(0, 10);
                if (iso) (serverByISO[iso] ||= []).push(e);
            });
            for (const iso of Object.keys(pendingMap)) {
                const arr = Array.isArray(pendingMap[iso]) ? pendingMap[iso] : [];
                pendingMap[iso] = arr.filter(p => !(serverByISO[iso] || []).some(s =>
                    (p.id && s.id && p.id === s.id) ||
                    (String(p.start || "").slice(0,16) === String(s.start || "").slice(0,16) && (p.title || "") === (s.title || ""))
                ));
                if (pendingMap[iso].length === 0) delete pendingMap[iso];
            }
            savePendingEventsMap(pendingMap);
            const pendingFiltered = getAllPendingEvents();
            globalEvents = [...serverEvents, ...pendingFiltered].sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));
            saveLocalEvents();
            setSyncStatus("완료");
            renderList();
        } catch (err) {
            console.error(err);
            setSyncStatus("실패");
            renderList();
        }
    }

    function renderList() {
        const savedScroll = list.scrollTop;
        list.innerHTML = "";
        const esc = (s) => String(s || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;");
        const escId = (id) => String(id || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'");

        const today = getTodayISO();
        const showPast = showPastCheck ? showPastCheck.checked : false;

        let filtered = globalEvents.filter(e => {
            const dateStr = String(e.start || e.date || "").slice(0, 10);
            if (!dateStr) return false;
            const isPast = dateStr < today;
            if (!showPast && isPast) return false;
            if (viewFilter === "today") return dateStr === today;
            if (viewFilter === "7day") return dateStr >= today && dateStr <= getDateOffset(today, 7);
            if (viewFilter === "30day") return dateStr >= today && dateStr <= getDateOffset(today, 30);
            return true;
        }).sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));

        const displayEvents = filtered.slice(0, 80);

        const groupByDate = {};
        displayEvents.forEach(ev => {
            const ds = String(ev.start || ev.date || "").slice(0, 10) || today;
            (groupByDate[ds] ||= []).push(ev);
        });

        const labels = { [today]: "오늘" };
        const tomorrow = getDateOffset(today, 1);
        labels[tomorrow] = "내일";

        const sortedDates = Object.keys(groupByDate).sort();
        sortedDates.forEach(dateStr => {
            const evs = groupByDate[dateStr];
            const isPastDate = dateStr < today;
            const label = labels[dateStr] || dateStr;
            if (isPastDate && sortedDates.indexOf(dateStr) === sortedDates.findIndex(d => d < today)) {
                const pastHeader = document.createElement("div");
                pastHeader.className = "section-header";
                pastHeader.textContent = "지난 일정";
                list.appendChild(pastHeader);
            }
            const header = document.createElement("div");
            header.className = "section-header";
            header.textContent = label;
            list.appendChild(header);
            evs.forEach(ev => {
                const evDateStr = String(ev.start || ev.date || "").slice(0,10) || today;
                const isPast = evDateStr < today;
                const div = document.createElement("div");
                div.className = `schedule-item ${String(ev.id || "").startsWith("temp-") || String(ev.id || "").startsWith("off-") ? "is-temp" : ""} ${isPast ? "is-past" : ""}`;
                const timeStr = formatTimeRangeForDisplay(ev.start, ev.end);
                const meta = timeStr ? `${evDateStr} ${timeStr}` : evDateStr;
                div.innerHTML = `
                    <div class="schedule-left">
                        <div class="schedule-marker"></div>
                        <div>
                            <span class="text-content">${esc(ev.title || "schedule")}</span>
                            <div class="text-meta">${meta}</div>
                        </div>
                    </div>
                    <div class="schedule-item-actions">
                        <button type="button" class="btn-action btn-edit" title="수정" onclick="event.stopPropagation(); startEditEvent('${escId(ev.id)}'); return false;">✎</button>
                        <button type="button" class="btn-action btn-delete" title="삭제" onclick="event.stopPropagation(); deleteEvent('${escId(ev.id)}'); return false;">X</button>
                    </div>
                `;
                list.appendChild(div);
            });
        });

        if (countDisplay) countDisplay.innerText = `${displayEvents.length} SCHEDULED`;

        if (displayEvents.length === 0) {
            const empty = document.createElement("div");
            empty.style.padding = "16px";
            empty.style.color = "var(--accent-color)";
            empty.style.opacity = "0.7";
            empty.style.fontSize = "11px";
            empty.style.textAlign = "center";
            empty.textContent = "No schedule yet.\nAdd one above.";
            empty.style.whiteSpace = "pre";
            list.appendChild(empty);
        }
        requestAnimationFrame(() => { list.scrollTop = savedScroll; });
    }

    async function addEvent() {
        const title = inputTitle.value.trim();
        if (!title) return;

        const dtStart = inputStart.value || getTodayDatetimeLocal();
        const timeEnd = inputTimeEnd.value || "";
        const startISO = datetimeLocalToISO(dtStart);
        if (!startISO) return;

        const dateStr = dtStart.slice(0, 10);
        const endISO = timeEnd ? toISODateTime(dateStr, timeEnd) : null;

        const today = getTodayISO();
        const newId = OFFLINE_MODE ? 'off-' + Date.now() : 'temp-' + Date.now();
        const newEvent = {
            id: newId,
            title,
            start: startISO,
            end: endISO,
            date: dateStr,
            isSynced: OFFLINE_MODE,
            pending: !OFFLINE_MODE
        };
        globalEvents.push(newEvent);
        globalEvents.sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));

        if (!OFFLINE_MODE) {
            const pendingMap = loadPendingEventsMap();
            (pendingMap[dateStr] ||= []).unshift(newEvent);
            savePendingEventsMap(pendingMap);
        }

        bc.postMessage({ type: "EVENT_ADDED", event: newEvent });
        saveLocalEvents();
        inputTitle.value = "";
        inputTimeEnd.value = "";
        if (typeof dtResetToNow === "function") dtResetToNow();
        renderList();

        if (OFFLINE_MODE) {
            bc.postMessage({ type: "EVENTS_UPDATED" });
            return;
        }

        inFlight++;
        try {
            const res = await fetch('/api/notion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'createEvent', title, start: startISO, end: endISO })
            });

            if (!res.ok) {
                console.error("CREATE EVENT HTTP error:", res.status);
                setSyncStatus("생성 실패");
                renderList();
                return;
            }

            const data = await res.json().catch(() => null);
            if (!data?.success || !data?.id) {
                console.error("CREATE EVENT payload error:", data);
                setSyncStatus("생성 실패");
                renderList();
                return;
            }

            const target = globalEvents.find(e => e.id === newId);
            if (target) {
                target.id = data.id;
                target.isSynced = true;
                target.pending = true;
                const pendingMap = loadPendingEventsMap();
                for (const iso of Object.keys(pendingMap)) {
                    const idx = (pendingMap[iso] || []).findIndex(p => p.id === newId);
                    if (idx >= 0) { pendingMap[iso][idx] = { ...pendingMap[iso][idx], id: data.id }; break; }
                }
                savePendingEventsMap(pendingMap);
                saveLocalEvents();
                renderList();
                bc.postMessage({ type: "EVENTS_UPDATED" });
            }
        } catch (e) {
            console.error(e);
            setSyncStatus("네트워크 오류");
            renderList();
        } finally {
            inFlight--;
        }
    }

    function startEditEvent(id) {
        editingEventId = id;
        editTimeOverride = null;
        const ev = globalEvents.find(e => e.id === id);
        if (ev) {
            const ds = String(ev.start || ev.date || "").slice(0, 10);
            const [y, m, d] = ds ? ds.split("-").map(Number) : [new Date().getFullYear(), new Date().getMonth() + 1, new Date().getDate()];
            editViewYear = y || new Date().getFullYear();
            editViewMonth = (m || new Date().getMonth() + 1) - 1;
            editPickedDate = { y: editViewYear, m: editViewMonth + 1, d: d || new Date().getDate() };
        }
        openEditModal(ev);
        renderList();
    }
    function openEditModal(ev) {
        const modal = document.getElementById("editModal");
        const overlay = document.getElementById("editModalOverlay");
        if (!modal || !overlay || !ev) return;
        const esc = (s) => String(s || "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;");
        const startHhmm = extractHHmm(ev.start) || "00:00";
        const endHhmm = extractHHmm(ev.end) || startHhmm;
        const [sh, sm] = editTimeOverride ? [editTimeOverride.h, editTimeOverride.m] : startHhmm.split(":").map(n => parseInt(n, 10) || 0);
        const [eh, em] = editTimeOverride ? [editTimeOverride.he, editTimeOverride.me] : endHhmm.split(":").map(n => parseInt(n, 10) || 0);
        if (editTimeOverride) editTimeOverride = null;
        const gridHtml = getEditCalendarGridHTML();
        modal.innerHTML = `
            <div style="margin-bottom:10px;">
                <input type="text" id="editEventInput" value="${esc(ev.title || "")}" maxlength="80" style="width:100%; background:#0b0c10; border:1px solid var(--border-color); color:var(--text-color); padding:8px 10px; font-size:12px; outline:none;">
            </div>
            <div class="edit-picker">
                <div class="dt-picker-header">
                    <div class="dt-picker-nav">
                        <button type="button" class="dt-picker-nav-btn" onclick="editPrevMonth(); redrawEditModal(); return false;">‹</button>
                        <span class="dt-picker-month">${editViewYear}년 ${editViewMonth + 1}월</span>
                        <button type="button" class="dt-picker-nav-btn" onclick="editNextMonth(); redrawEditModal(); return false;">›</button>
                    </div>
                    <span class="dt-picker-now" onclick="editNow(); redrawEditModal(); return false;">지금</span>
                </div>
                <div class="dt-picker-dow">
                    <span>일</span><span>월</span><span>화</span><span>수</span><span>목</span><span>금</span><span>토</span>
                </div>
                <div class="dt-picker-grid" id="editCalendarGrid">${gridHtml}</div>
                <div class="dt-picker-time">
                    <div class="dt-picker-time-row">
                        <label>시작 시간</label>
                        <input type="number" id="editEventHour" min="0" max="23" value="${sh}" />
                        <span>:</span>
                        <input type="number" id="editEventMin" min="0" max="59" value="${sm}" />
                        <span style="font-size: 9px; opacity: 0.8;" id="editEventAmpm">${sh < 12 ? "오전" : "오후"}</span>
                    </div>
                    <div class="dt-picker-time-row">
                        <label>종료 시간</label>
                        <input type="number" id="editEventHourEnd" min="0" max="23" value="${eh}" />
                        <span>:</span>
                        <input type="number" id="editEventMinEnd" min="0" max="59" value="${em}" />
                        <span style="font-size: 9px; opacity: 0.8;" id="editEventAmpmEnd">${eh < 12 ? "오전" : "오후"}</span>
                    </div>
                </div>
            </div>
            <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
                <button type="button" class="btn-action btn-delete" onclick="cancelEditEvent(); return false;">취소</button>
                <button type="button" class="btn-action btn-edit" onclick="saveEditEvent(); return false;">저장</button>
            </div>
        `;
        modal.querySelector("#editCalendarGrid").querySelectorAll(".dt-picker-day").forEach(btn => {
            btn.addEventListener("click", () => {
                editPickedDate = { y: +btn.dataset.y, m: +(btn.dataset.m) + 1, d: +btn.dataset.d };
                redrawEditModal();
            });
        });
        const updateEditAmpm = () => {
            const a = document.getElementById("editEventAmpm"); const ae = document.getElementById("editEventAmpmEnd");
            const h = parseInt(document.getElementById("editEventHour")?.value, 10) || 0;
            const he = parseInt(document.getElementById("editEventHourEnd")?.value, 10) || 0;
            if (a) a.textContent = h < 12 ? "오전" : "오후";
            if (ae) ae.textContent = he < 12 ? "오전" : "오후";
        };
        modal.querySelector("#editEventHour")?.addEventListener("input", updateEditAmpm);
        modal.querySelector("#editEventHourEnd")?.addEventListener("input", updateEditAmpm);
        modal.querySelector("#editEventInput")?.addEventListener("keydown", (e) => { if (e.key==="Enter") saveEditEvent(); if (e.key==="Escape") cancelEditEvent(); });
        overlay.classList.remove("hidden");
        overlay.onclick = (e) => { if (e.target === overlay) cancelEditEvent(); };
        setTimeout(() => modal.querySelector("#editEventInput")?.focus(), 50);
    }
    function redrawEditModal() {
        const ev = globalEvents.find(e => e.id === editingEventId);
        if (!ev) return;
        const inp = document.getElementById("editEventInput");
        const h = document.getElementById("editEventHour"); const m = document.getElementById("editEventMin");
        const he = document.getElementById("editEventHourEnd"); const me = document.getElementById("editEventMinEnd");
        if (inp) ev.title = inp.value;
        if (h != null && m != null) {
            const pd = editPickedDate || { y: new Date().getFullYear(), m: new Date().getMonth() + 1, d: new Date().getDate() };
            const dateStr = `${pd.y}-${String(pd.m).padStart(2,"0")}-${String(pd.d).padStart(2,"0")}`;
            ev.start = toISODateTime(dateStr, `${String(parseInt(h.value,10)||0).padStart(2,"0")}:${String(parseInt(m.value,10)||0).padStart(2,"0")}`);
        }
        if (he != null && me != null) {
            const pd = editPickedDate || { y: new Date().getFullYear(), m: new Date().getMonth() + 1, d: new Date().getDate() };
            const dateStr = `${pd.y}-${String(pd.m).padStart(2,"0")}-${String(pd.d).padStart(2,"0")}`;
            ev.end = toISODateTime(dateStr, `${String(parseInt(he.value,10)||0).padStart(2,"0")}:${String(parseInt(me.value,10)||0).padStart(2,"0")}`);
        }
        openEditModal(ev);
    }
    function editPrevMonth() {
        editViewMonth--; if (editViewMonth < 0) { editViewMonth = 11; editViewYear--; }
        redrawEditModal();
    }
    function editNextMonth() {
        editViewMonth++; if (editViewMonth > 11) { editViewMonth = 0; editViewYear++; }
        redrawEditModal();
    }
    function editNow() {
        const n = new Date();
        editViewYear = n.getFullYear(); editViewMonth = n.getMonth();
        editPickedDate = { y: editViewYear, m: editViewMonth + 1, d: n.getDate() };
        const endMin = n.getMinutes() + 60;
        const endH = Math.min(23, n.getHours() + Math.floor(endMin / 60));
        const endM = endH >= 23 ? 59 : endMin % 60;
        editTimeOverride = { h: n.getHours(), m: n.getMinutes(), he: endH, me: endM };
        redrawEditModal();
    }
    function cancelEditEvent() {
        document.getElementById("editModalOverlay")?.classList.add("hidden");
        editingEventId = null;
        editTimeOverride = null;
        renderList();
    }
    async function saveEditEvent() {
        const inp = document.getElementById("editEventInput");
        const hourInp = document.getElementById("editEventHour");
        const minInp = document.getElementById("editEventMin");
        const hourEndInp = document.getElementById("editEventHourEnd");
        const minEndInp = document.getElementById("editEventMinEnd");
        const newTitle = inp ? inp.value.trim() : "";
        if (!newTitle || !editingEventId) { cancelEditEvent(); return; }
        const ev = globalEvents.find(e => e.id === editingEventId);
        if (!ev) { cancelEditEvent(); return; }
        const pd = editPickedDate || { y: new Date().getFullYear(), m: new Date().getMonth() + 1, d: new Date().getDate() };
        const dateStr = `${pd.y}-${String(pd.m).padStart(2,"0")}-${String(pd.d).padStart(2,"0")}`;
        const h = Math.min(23, Math.max(0, parseInt(hourInp?.value, 10) || 0));
        const m = Math.min(59, Math.max(0, parseInt(minInp?.value, 10) || 0));
        const he = Math.min(23, Math.max(0, parseInt(hourEndInp?.value, 10) || 0));
        const me = Math.min(59, Math.max(0, parseInt(minEndInp?.value, 10) || 0));
        const startHhmm = `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}`;
        const endHhmm = `${String(he).padStart(2,"0")}:${String(me).padStart(2,"0")}`;
        const newStartISO = toISODateTime(dateStr, startHhmm);
        const newEndISO = endHhmm ? toISODateTime(dateStr, endHhmm) : newStartISO;
        ev.title = newTitle;
        ev.start = newStartISO;
        ev.end = endHhmm ? newEndISO : null;
        ev.date = dateStr;
        if (OFFLINE_MODE) {
            document.getElementById("editModalOverlay")?.classList.add("hidden");
            saveLocalEvents();
            editingEventId = null;
            renderList();
            bc.postMessage({ type: "EVENTS_UPDATED" });
            return;
        }
        if (String(editingEventId).startsWith("temp-") || String(editingEventId).startsWith("off-")) {
            const pendingMap = loadPendingEventsMap();
            const oldDateStr = String(ev.start || ev.date || "").slice(0, 10);
            if (oldDateStr && pendingMap[oldDateStr]) {
                pendingMap[oldDateStr] = pendingMap[oldDateStr].filter(p => p.id !== editingEventId);
                if (pendingMap[oldDateStr].length === 0) delete pendingMap[oldDateStr];
            }
            (pendingMap[dateStr] ||= []).unshift(ev);
            savePendingEventsMap(pendingMap);
            globalEvents.sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));
            document.getElementById("editModalOverlay")?.classList.add("hidden");
            editingEventId = null;
            saveLocalEvents();
            renderList();
            bc.postMessage({ type: "EVENTS_UPDATED" });
            return;
        }
        inFlight++;
        try {
            const res = await fetch("/api/notion", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ action: "updateEvent", pageId: editingEventId, title: newTitle, start: newStartISO, end: endHhmm ? newEndISO : newStartISO })
            });
            const data = await res.json().catch(() => null);
            if (data?.success) {
                globalEvents.sort((a, b) => String(a.start || "").localeCompare(String(b.start || "")));
                saveLocalEvents();
                bc.postMessage({ type: "EVENTS_UPDATED" });
            } else {
                setSyncStatus("수정 실패");
            }
        } catch (e) { console.error(e); setSyncStatus("네트워크 오류"); }
        finally { inFlight--; }
        document.getElementById("editModalOverlay")?.classList.add("hidden");
        editingEventId = null;
        editTimeOverride = null;
        renderList();
    }

    async function deleteEvent(id) {
        const target = globalEvents.find(e => e.id === id);
        globalEvents = globalEvents.filter(e => e.id !== id);
        const pendingMap = loadPendingEventsMap();
        for (const iso of Object.keys(pendingMap)) {
            pendingMap[iso] = (pendingMap[iso] || []).filter(p => p.id !== id);
            if (pendingMap[iso].length === 0) delete pendingMap[iso];
        }
        savePendingEventsMap(pendingMap);
        saveLocalEvents();
        renderList();
        bc.postMessage({ type: "EVENTS_UPDATED" });

        if (OFFLINE_MODE) return;
        if (!target) return;
        if (!String(id).startsWith('temp-') && !String(id).startsWith('off-')) {
            try {
                await fetch('/api/notion', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'deleteEvent', pageId: id })
                });
            } catch (e) { console.error("DELETE EVENT error:", e); }
        }
    }

    inputTitle.addEventListener("keypress", (e) => { if (e.key === "Enter") addEvent(); });

    document.querySelectorAll(".filter-chip").forEach(btn => {
        btn.addEventListener("click", () => {
            viewFilter = btn.dataset.filter;
            document.querySelectorAll(".filter-chip").forEach(b => b.classList.toggle("active", b === btn));
            renderList();
        });
    });
    if (showPastCheck) showPastCheck.addEventListener("change", renderList);

    if (OFFLINE_MODE) document.getElementById("offlineBadge").style.display = "inline";
    // ——— 커스텀 날짜·시간 피커 ———
    const dtTrigger = document.getElementById("dt-picker-trigger");
    const dtDrop = document.getElementById("dt-picker-drop");
    const dtMonthLabel = document.getElementById("dt-month-label");
    const dtCalendarGrid = document.getElementById("dt-calendar-grid");
    const dtPrevMonth = document.getElementById("dt-prev-month");
    const dtNextMonth = document.getElementById("dt-next-month");
    const dtHour = document.getElementById("dt-hour");
    const dtMin = document.getElementById("dt-min");
    const dtAmpm = document.getElementById("dt-ampm");
    const dtHourEnd = document.getElementById("dt-hour-end");
    const dtMinEnd = document.getElementById("dt-min-end");
    const dtAmpmEnd = document.getElementById("dt-ampm-end");
    const dtNow = document.getElementById("dt-now");

    let pickedDate = null; // { y, m, d } — 선택된 날짜
    let viewYear = new Date().getFullYear();
    let viewMonth = new Date().getMonth();

    function preventScrollOnFocus(el) {
        if (!el) return;
        const listEl = document.getElementById("list");
        const handler = (e) => {
            e.preventDefault();
            const scrollTop = listEl ? listEl.scrollTop : 0;
            const restore = () => { if (listEl) listEl.scrollTop = scrollTop; };
            el.focus({ preventScroll: true });
            requestAnimationFrame(restore);
            [0, 50, 100, 200, 400, 600].forEach(ms => setTimeout(restore, ms));
        };
        el.addEventListener("mousedown", handler);
        el.addEventListener("touchstart", handler, { passive: false });
    }

    function dtToDatetimeLocal() {
        const d = pickedDate || { y: new Date().getFullYear(), m: new Date().getMonth() + 1, d: new Date().getDate() };
        const h = Math.min(23, Math.max(0, parseInt(dtHour.value, 10) || 0));
        const min = Math.min(59, Math.max(0, parseInt(dtMin.value, 10) || 0));
        const ys = String(d.y); const ms = String(d.m).padStart(2, "0"); const ds = String(d.d).padStart(2, "0");
        return `${ys}-${ms}-${ds}T${String(h).padStart(2,"0")}:${String(min).padStart(2,"0")}`;
    }
    function dtToTimeEnd() {
        const he = Math.min(23, Math.max(0, parseInt(dtHourEnd.value, 10) || 0));
        const me = Math.min(59, Math.max(0, parseInt(dtMinEnd.value, 10) || 0));
        return `${String(he).padStart(2,"0")}:${String(me).padStart(2,"0")}`;
    }
    function dtUpdateInputAndDisplay() {
        const dtLocal = dtToDatetimeLocal();
        inputStart.value = dtLocal;
        const endHhmm = dtToTimeEnd();
        inputTimeEnd.value = endHhmm;
        const [_, timePart] = dtLocal.split("T");
        const [h, m] = (timePart || "00:00").split(":");
        const hh = parseInt(h, 10) || 0;
        dtAmpm.textContent = hh < 12 ? "오전" : "오후";
        const [he, me] = endHhmm.split(":");
        const hhe = parseInt(he, 10) || 0;
        dtAmpmEnd.textContent = hhe < 12 ? "오전" : "오후";
    }
    function dtRenderCalendar() {
        dtMonthLabel.textContent = `${viewYear}년 ${viewMonth + 1}월`;
        const first = new Date(viewYear, viewMonth, 1);
        const last = new Date(viewYear, viewMonth + 1, 0);
        const startDow = first.getDay();
        const daysInMonth = last.getDate();
        const today = new Date();
        const todayY = today.getFullYear(), todayM = today.getMonth(), todayD = today.getDate();

        let html = "";
        const prevMonth = viewMonth === 0 ? 11 : viewMonth - 1;
        const prevYear = viewMonth === 0 ? viewYear - 1 : viewYear;
        const prevLast = new Date(prevYear, prevMonth + 1, 0).getDate();
        for (let i = 0; i < startDow; i++) {
            const d = prevLast - startDow + i + 1;
            html += `<button type="button" class="dt-picker-day other" data-y="${prevYear}" data-m="${prevMonth}" data-d="${d}">${d}</button>`;
        }
        for (let d = 1; d <= daysInMonth; d++) {
            let cls = "dt-picker-day";
            if (viewYear === todayY && viewMonth === todayM && d === todayD) cls += " today";
            if (pickedDate && pickedDate.y === viewYear && pickedDate.m === viewMonth + 1 && pickedDate.d === d) cls += " selected";
            html += `<button type="button" class="${cls}" data-y="${viewYear}" data-m="${viewMonth}" data-d="${d}">${d}</button>`;
        }
        const nextMonth = viewMonth === 11 ? 0 : viewMonth + 1;
        const nextYear = viewMonth === 11 ? viewYear + 1 : viewYear;
        const remaining = 42 - (startDow + daysInMonth);
        for (let d = 1; d <= Math.min(remaining, 14); d++) {
            html += `<button type="button" class="dt-picker-day other" data-y="${nextYear}" data-m="${nextMonth}" data-d="${d}">${d}</button>`;
        }
        dtCalendarGrid.innerHTML = html;
        dtCalendarGrid.querySelectorAll(".dt-picker-day").forEach(btn => {
            btn.addEventListener("click", () => {
                pickedDate = { y: +btn.dataset.y, m: +(btn.dataset.m) + 1, d: +btn.dataset.d };
                dtUpdateInputAndDisplay();
                dtRenderCalendar();
            });
        });
    }
    dtTrigger.addEventListener("click", (e) => {
        e.stopPropagation();
        const isHidden = dtDrop.classList.contains("hidden");
        dtDrop.classList.toggle("hidden", !isHidden);
        if (isHidden) dtRenderCalendar();
    });
    document.addEventListener("click", (e) => {
        if (!dtDrop.contains(e.target) && !dtTrigger.contains(e.target)) dtDrop.classList.add("hidden");
    });
    dtPrevMonth.addEventListener("click", () => { viewMonth--; if (viewMonth < 0) { viewMonth = 11; viewYear--; } dtRenderCalendar(); });
    dtNextMonth.addEventListener("click", () => { viewMonth++; if (viewMonth > 11) { viewMonth = 0; viewYear++; } dtRenderCalendar(); });
    dtNow.addEventListener("click", () => {
        const n = new Date();
        viewYear = n.getFullYear(); viewMonth = n.getMonth();
        pickedDate = { y: viewYear, m: viewMonth + 1, d: n.getDate() };
        dtHour.value = n.getHours(); dtMin.value = n.getMinutes();
        const endMin = n.getMinutes() + 60;
        let endH = Math.min(23, n.getHours() + Math.floor(endMin / 60));
        let endM = endH >= 23 ? 59 : endMin % 60;
        dtHourEnd.value = endH; dtMinEnd.value = endM;
        dtUpdateInputAndDisplay();
        dtRenderCalendar();
        dtDrop.classList.add("hidden");
    });
    dtHour.addEventListener("input", dtUpdateInputAndDisplay);
    dtMin.addEventListener("input", dtUpdateInputAndDisplay);
    preventScrollOnFocus(dtHour); preventScrollOnFocus(dtMin); preventScrollOnFocus(dtHourEnd); preventScrollOnFocus(dtMinEnd);
    dtHour.addEventListener("change", () => { dtHour.value = Math.min(23, Math.max(0, parseInt(dtHour.value, 10) || 0)); dtUpdateInputAndDisplay(); });
    dtMin.addEventListener("change", () => { dtMin.value = Math.min(59, Math.max(0, parseInt(dtMin.value, 10) || 0)); dtUpdateInputAndDisplay(); });
    dtHourEnd.addEventListener("input", dtUpdateInputAndDisplay);
    dtMinEnd.addEventListener("input", dtUpdateInputAndDisplay);
    dtHourEnd.addEventListener("change", () => { dtHourEnd.value = Math.min(23, Math.max(0, parseInt(dtHourEnd.value, 10) || 0)); dtUpdateInputAndDisplay(); });
    dtMinEnd.addEventListener("change", () => { dtMinEnd.value = Math.min(59, Math.max(0, parseInt(dtMinEnd.value, 10) || 0)); dtUpdateInputAndDisplay(); });

    function dtResetToNow() {
        const n = new Date();
        viewYear = n.getFullYear(); viewMonth = n.getMonth();
        pickedDate = { y: viewYear, m: viewMonth + 1, d: n.getDate() };
        dtHour.value = n.getHours(); dtMin.value = n.getMinutes();
        const endMin = n.getMinutes() + 60;
        let endH = Math.min(23, n.getHours() + Math.floor(endMin / 60));
        let endM = endH >= 23 ? 59 : endMin % 60;
        dtHourEnd.value = endH; dtMinEnd.value = endM;
        dtUpdateInputAndDisplay();
        dtRenderCalendar();
    }

    if (!pickedDate) {
        const n = new Date();
        pickedDate = { y: n.getFullYear(), m: n.getMonth() + 1, d: n.getDate() };
        dtHour.value = n.getHours();
        dtMin.value = n.getMinutes();
        const endMin = n.getMinutes() + 60;
        let endH = Math.min(23, n.getHours() + Math.floor(endMin / 60));
        let endM = endH >= 23 ? 59 : endMin % 60;
        dtHourEnd.value = endH; dtMinEnd.value = endM;
    }
    dtUpdateInputAndDisplay();
    dtRenderCalendar();

    loadLocalEvents();
    renderList();
    syncFromNotion();
    setInterval(syncFromNotion, 5000);
</script>
</body>
</html>
